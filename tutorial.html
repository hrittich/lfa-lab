
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tutorial &#8212; LFA Lab 0.4.0-alpha documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API" href="api.html" />
    <link rel="prev" title="Installation" href="install.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>For this introduction to LFA Lab, we assume that you have successfully
installed our software. (If this is not the case, see <a class="reference internal" href="install.html#installation"><span class="std std-ref">Installation</span></a>). We
start with a simple example.</p>
<div class="section" id="the-jacobi-method">
<span id="tut-jacobi-method"></span><h2>The Jacobi Method<a class="headerlink" href="#the-jacobi-method" title="Permalink to this headline">¶</a></h2>
<p>For the beginning we start with the Jacobi method applied to the Poisson
equation (see <a class="reference internal" href="glossary.html#poisson-equation"><span class="std std-ref">Poisson Equation</span></a>). The following example uses LFA Lab to
compute spectral radius of the error propagator of the method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lfa_lab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Create a 2D grid with step-size (1/32, 1/32).</span>
<span class="n">fine</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">])</span>

<span class="c1"># Create a poisson operator.</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">poisson_2d</span><span class="p">(</span><span class="n">fine</span><span class="p">)</span>

<span class="c1"># Create the jacobi smoother for L.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>

<span class="c1"># Compute the symbol of S.</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span>

<span class="c1"># Print spectral radius of S.</span>
<span class="nb">print</span><span class="p">((</span><span class="n">symbol</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()))</span>
</pre></div>
</div>
<p>Let us walk through this example step by step.  To make any analysis, we first
have to define a grid, i.e., create an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">lfa_kernel.Grid</span></code>, because all operators that we can analyze by LFA
must be defined on a grid.</p>
<p>Then, we can create the operator corresponding to the Poisson equation. We
call the function <a class="reference internal" href="api.html#lfa_lab.gallery.poisson_2d" title="lfa_lab.gallery.poisson_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.gallery.poisson_2d()</span></code></a> for this purpose. The
module <a class="reference internal" href="api.html#module-lfa_lab.gallery" title="lfa_lab.gallery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lfa_lab.gallery</span></code></a> contains further predefined operators that
you can use.</p>
<p>In the next step, we create the error propagator of the Jacobi method for the
Poisson equation, using the <a class="reference internal" href="api.html#lfa_lab.smoother.jacobi" title="lfa_lab.smoother.jacobi"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.smoother.jacobi()</span></code></a> function. This
function can only be used with operators that are defined by a stencil. How to
define such an operator will be discussed in the section
<a class="reference internal" href="#defining-stencil-operators"><span class="std std-ref">Defining Stencil Operators</span></a>.</p>
<p>The symbol of the error propagation operator of the Jacobi method is then
computed. Note, that this is the point where the actual computation happens,
all other operations before the computation of the symbol are merely
definitions. Since the computation of the symbol can be quite expensive, you
should store the symbol, when you want to investigate multiple of its
properties. (For the properties of a symbol, see
<code class="xref py py-class docutils literal notranslate"><span class="pre">lfa_kernel.Symbol</span></code>.)</p>
<p>The last step is, to compute the spectral radius of the error propagation
operator. This command will output a value of 0.996 for the spectral radius.</p>
</div>
<div class="section" id="plotting-symbols">
<h2>Plotting Symbols<a class="headerlink" href="#plotting-symbols" title="Permalink to this headline">¶</a></h2>
<p>The <em>Fourier symbol</em> <span class="math notranslate nohighlight">\(\hat{s}\)</span> of the operator <span class="math notranslate nohighlight">\(S\)</span> is a
description of the operator <span class="math notranslate nohighlight">\(S\)</span>.  The symbol assigns every value from
<span class="math notranslate nohighlight">\([0, \tfrac{2\pi}{h_1}) \times \cdots \times [0, \tfrac{2\pi}{h_d})\)</span> a
complex number, such that the following holds. If <span class="math notranslate nohighlight">\(\hat{u}\)</span> and
<span class="math notranslate nohighlight">\(\hat{f}\)</span> are the <em>discrete time Fourier transforms</em> of the functions
<span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(f\)</span>, respectively, and <span class="math notranslate nohighlight">\(f = S u\)</span> then</p>
<div class="math notranslate nohighlight">
\[\hat{f} = \hat{s} \cdot \hat{u}\]</div>
<p>(pointwise multiplication). Hence, by plotting the symbol of an operator we can
impove out understanding of the corresponding operator.</p>
<p>The following code plots the Fourer symbol of the error propagator of the
Jacobi method for the discrete Poisson equation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lfa_lab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1"># To plot a symbol, we need to import matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">mpp</span>

<span class="n">fine</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">])</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">poisson_2d</span><span class="p">(</span><span class="n">fine</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span>

<span class="c1"># Plot the symbol</span>
<span class="n">plot</span><span class="o">.</span><span class="n">plot_2d</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

<span class="c1"># Tell matplotlib to show the plot.</span>
<span class="n">mpp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This code is just a modification to the example from the previous section. To
plot the symbol, we import the <a class="reference internal" href="glossary.html#matplotlib"><span class="std std-ref">Matplotlib</span></a> library. To plot the symbol
we use the function <a class="reference internal" href="api.html#lfa_lab.plot.plot_2d" title="lfa_lab.plot.plot_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.plot.plot_2d()</span></code></a>. (This function works only
for 2D problems. Problems in 1D should use the function
<a class="reference internal" href="api.html#lfa_lab.plot.plot_2d" title="lfa_lab.plot.plot_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.plot.plot_2d()</span></code></a>.) To actually display the plot, we need to use
the function <cite>show()</cite> of <a class="reference internal" href="glossary.html#matplotlib"><span class="std std-ref">Matplotlib</span></a>. The result is shown below.</p>
<img alt="_images/tutorial02-plot.png" src="_images/tutorial02-plot.png" />
<p>Note that LFA Lab uses the Frequency domain
<span class="math notranslate nohighlight">\([0, \tfrac{2\pi}{h_1}) \times \cdots \times [0, \tfrac{2\pi}{h_d})\)</span>.
This choice implies that the <em>low modes</em> are located near the corners of the
plot. (Recall that every mode that is node a low mode is called a <em>high
mode</em>).</p>
<p>By inspecting the plot and using the relation
<span class="math notranslate nohighlight">\(\hat{f} = \hat{s} \cdot \hat{u}\)</span>, we see that applying the operator
<span class="math notranslate nohighlight">\(S\)</span> returns a function that, in comparison to the input functions, has
smaller function values on the high modes. Hence, after some applications of
<span class="math notranslate nohighlight">\(S\)</span> the low modes will be dominating.</p>
<p>It is known that a function whose discrete time Fourier transform is dominant
in the low modes is slowly varying. Thus, multiple applications of <span class="math notranslate nohighlight">\(S\)</span>
result in a function which is slowly varying. Therefore, the Jacobi method is
a <em>smoother</em> for the discrete Poisson equation.</p>
</div>
<div class="section" id="smoothing-analysis">
<h2>Smoothing Analysis<a class="headerlink" href="#smoothing-analysis" title="Permalink to this headline">¶</a></h2>
<p>The smoothing effect of an operator <span class="math notranslate nohighlight">\(S\)</span> can be quantified by a so called
<em>smoothing analysis</em>. The idea of this analysis is to choose a filtering
operator <span class="math notranslate nohighlight">\(Z\)</span> that maps the low modes to zero while leaving the high
modes unchanged. (An operator like that is also called an <em>idealized coarse
grid correction</em>.)
Then, <span class="math notranslate nohighlight">\(ZS\)</span> characterizes how <span class="math notranslate nohighlight">\(S\)</span> acts on the high
modes. Hence, the smoothing effect of the operator <span class="math notranslate nohighlight">\(ZS\)</span> is quantified by
computing the spectral radius</p>
<div class="math notranslate nohighlight">
\[r(ZA)
\,.\]</div>
<p>The following code performs this computation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lfa_lab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fine</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">])</span>

<span class="c1"># Create a coarse grid by selecting every second point in the x- and every</span>
<span class="c1"># second point in the y-direction.</span>
<span class="n">coarse</span> <span class="o">=</span> <span class="n">fine</span><span class="o">.</span><span class="n">coarse</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">poisson_2d</span><span class="p">(</span><span class="n">fine</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>

<span class="c1"># Create the filtering operator.</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">hp_filter</span><span class="p">(</span><span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>

<span class="c1"># Apply the filter to the smoother. After applying smoother all low modes are</span>
<span class="c1"># removed from the spectrum.</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">F</span> <span class="o">*</span> <span class="n">S</span>

<span class="nb">print</span><span class="p">((</span><span class="n">E</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()))</span>
</pre></div>
</div>
<p>Note, a smoothing analysis can directly be performed by using the convenience
function <a class="reference internal" href="api.html#lfa_lab.analysis.smoothing_factor" title="lfa_lab.analysis.smoothing_factor"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.analysis.smoothing_factor()</span></code></a>.</p>
</div>
<div class="section" id="two-grids">
<span id="tutorial-two-grids"></span><h2>Two Grids<a class="headerlink" href="#two-grids" title="Permalink to this headline">¶</a></h2>
<p>The two-grid method requires</p>
<ul class="simple">
<li><p>a smoothing operator <span class="math notranslate nohighlight">\(S\)</span> and</p></li>
<li><p>a coarse grid correction <span class="math notranslate nohighlight">\(E_\mathrm{cgc}\)</span>.</p></li>
</ul>
<p>The error propagator of the two-grid method is the given by</p>
<div class="math notranslate nohighlight">
\[E = S E_\mathrm{cgc} S \,.\]</div>
<p>To construct the coarse grid correction error propagator we need</p>
<ul class="simple">
<li><p>the linear system operator of the fine grid <cite>L</cite>,</p></li>
<li><p>the linear system operator of the coarse grid <cite>Lc</cite>,</p></li>
<li><p>the restriction operator <cite>R</cite>, and</p></li>
<li><p>the interpolation operator <cite>P</cite>.</p></li>
</ul>
<p>This error propagator can be computed using the
<a class="reference internal" href="api.html#lfa_lab.two_grid.coarse_grid_correction" title="lfa_lab.two_grid.coarse_grid_correction"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.two_grid.coarse_grid_correction()</span></code></a> function. This function
does nothing more than to evaluate the formula (see
<a class="reference internal" href="glossary.html#error-coarse-grid-correction"><span class="std std-ref">Coarse Grid Correction</span></a>) for the coarse grid correction. It is,
however, better to use the predefined function in LFA lab to avoid typos.</p>
<p>The following code computes the required operators, then the error propagator
of the coarse grid correction, and then the error propagator of the entire
two-grid method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lfa_lab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fine</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">])</span>
<span class="n">coarse</span> <span class="o">=</span> <span class="n">fine</span><span class="o">.</span><span class="n">coarse</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">poisson_2d</span><span class="p">(</span><span class="n">fine</span><span class="p">)</span>
<span class="n">Lc</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">poisson_2d</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>

<span class="c1"># Create restriction and interpolation operators.</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">fw_restriction</span><span class="p">(</span><span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">ml_interpolation</span><span class="p">(</span><span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>

<span class="c1"># Construct the coarse grid correction from the individual operators.</span>
<span class="n">cgc</span> <span class="o">=</span> <span class="n">coarse_grid_correction</span><span class="p">(</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span>
        <span class="n">coarse_operator</span> <span class="o">=</span> <span class="n">Lc</span><span class="p">,</span>
        <span class="n">interpolation</span> <span class="o">=</span> <span class="n">P</span><span class="p">,</span>
        <span class="n">restriction</span> <span class="o">=</span> <span class="n">R</span><span class="p">)</span>

<span class="c1"># Apply one pre- and one post-smoothing step.</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">cgc</span> <span class="o">*</span> <span class="n">S</span>

<span class="nb">print</span><span class="p">((</span><span class="n">E</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-stencil-operators">
<span id="id1"></span><h2>Defining Stencil Operators<a class="headerlink" href="#defining-stencil-operators" title="Permalink to this headline">¶</a></h2>
<p>Up to this point we used the functions from the
<a class="reference internal" href="api.html#module-lfa_lab.gallery" title="lfa_lab.gallery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lfa_lab.gallery</span></code></a> module, to create different operators. We shall now
discuss how to define these operators manually.
Let us start with the Laplace operator.</p>
<p>The stencil of the discrete Laplace operator is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
  &amp; -\frac{1}{h_2^2} \\
  -\frac{1}{h_1^2} &amp; \left( \frac{2}{h_1^2} + \frac{2}{h_2^2} \right) &amp; -\frac{1}{h_1^2} \\
  &amp; -\frac{1}{h_2^2}
\end{bmatrix}_{\mathbf{h}}
\,.\end{split}\]</div>
<p>In LFA Lab stencils are described by a list containing stencil entries. Each
stencil entry is a tuple consisting of the offset of the entry and the
coefficient of the entry:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="p">((</span><span class="n">o1_x</span><span class="p">,</span> <span class="n">o1_y</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span> <span class="n">v1</span><span class="p">),</span> <span class="p">((</span><span class="n">o2_x</span><span class="p">,</span> <span class="n">o2_y</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span> <span class="n">v2</span><span class="p">),</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
<p>Using the <a class="reference internal" href="api.html#lfa_lab.operator.from_stencil" title="lfa_lab.operator.from_stencil"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.operator.from_stencil()</span></code></a> function, we can turn this
description of a stencil into an operator that we can use in our analysis. The
following code constructs the stencil for the discrete Laplace operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h1</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span>
<span class="n">h2</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span>
<span class="n">entries</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span><span class="o">*</span><span class="n">h2</span><span class="p">)),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h1</span><span class="o">*</span><span class="n">h1</span><span class="p">)),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span>  <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h1</span><span class="o">*</span><span class="n">h1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span><span class="o">*</span><span class="n">h2</span><span class="p">)),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h1</span><span class="o">*</span><span class="n">h1</span><span class="p">)),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span><span class="o">*</span><span class="n">h2</span><span class="p">))</span>
  <span class="p">]</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">from_stencil</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
</pre></div>
</div>
<p>Defining an interpolation and restriction operator is slightly more
complicated.</p>
<p>A stencil operator defined using <a class="reference internal" href="api.html#lfa_lab.operator.from_stencil" title="lfa_lab.operator.from_stencil"><code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.operator.from_stencil()</span></code></a> maps
from a grid with a step-size <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> to a grid with the same
step-size <span class="math notranslate nohighlight">\(\mathbf{h}\)</span>. Combining a stencil operator with a canonical
injection or canonical restriction (see <a class="reference internal" href="glossary.html#injection-restriction"><span class="std std-ref">Injection Restriction</span></a> and
<a class="reference internal" href="glossary.html#injection-interpolation"><span class="std std-ref">Injection Interpolation</span></a>), however, is usually sufficient
to define the desired interpolation or restriction operator.</p>
<p>More precisely, to define an interpolation operator we usually combine a
stencil operator <span class="math notranslate nohighlight">\(P_\mathrm{st}\)</span> and the injection interpolation
<span class="math notranslate nohighlight">\(P_\mathrm{inj}\)</span> to define the desired interpolation by</p>
<div class="math notranslate nohighlight">
\[P = P_\mathrm{st} P_\mathrm{inj}
\,.\]</div>
<p>Furthermore, to define a restriction operator we usually combin a stencil
operator <span class="math notranslate nohighlight">\(R_\mathrm{st}\)</span> and the injection restriction
<span class="math notranslate nohighlight">\(R_\mathrm{inj}\)</span> to define the destired restriction by</p>
<div class="math notranslate nohighlight">
\[R = R_\mathrm{inj} R_\mathrm{st}
\,.\]</div>
<p>For example to construct the linear interpolation with standard coarsening in
2D we can use the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entries</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
  <span class="p">]</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">from_stencil</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">fine</span><span class="p">)</span> <span class="o">*</span> \
        <span class="n">operator</span><span class="o">.</span><span class="n">injection_interpolation</span><span class="p">(</span><span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
</pre></div>
</div>
<p>We give below a complete example for user defined stencils.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lfa_lab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fine</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">])</span>
<span class="n">coarse</span> <span class="o">=</span> <span class="n">fine</span><span class="o">.</span><span class="n">coarse</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># A simple function that computes the poisson stencil for a given grid.</span>
<span class="k">def</span> <span class="nf">my_poisson_2d</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">step_size</span><span class="p">()</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span><span class="o">*</span><span class="n">h2</span><span class="p">)),</span>
        <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h1</span><span class="o">*</span><span class="n">h1</span><span class="p">)),</span>
        <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span>  <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h1</span><span class="o">*</span><span class="n">h1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span><span class="o">*</span><span class="n">h2</span><span class="p">)),</span>
        <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h1</span><span class="o">*</span><span class="n">h1</span><span class="p">)),</span>
        <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span><span class="o">*</span><span class="n">h2</span><span class="p">))</span>
      <span class="p">]</span>
    <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">from_stencil</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">my_poisson_2d</span><span class="p">(</span><span class="n">fine</span><span class="p">)</span>
<span class="n">Lc</span> <span class="o">=</span> <span class="n">my_poisson_2d</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>

<span class="c1"># Create the restriction operator</span>
<span class="n">entries</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">16</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">16</span><span class="p">),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">16</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">16</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">injection_restriction</span><span class="p">(</span><span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span> <span class="o">*</span> \
        <span class="n">operator</span><span class="o">.</span><span class="n">from_stencil</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">fine</span><span class="p">)</span>

<span class="c1"># Create the interpolation operator.</span>
<span class="n">entries</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">((</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
  <span class="p">]</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">from_stencil</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">fine</span><span class="p">)</span> <span class="o">*</span> \
        <span class="n">operator</span><span class="o">.</span><span class="n">injection_interpolation</span><span class="p">(</span><span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>

<span class="n">cgc</span> <span class="o">=</span> <span class="n">coarse_grid_correction</span><span class="p">(</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span>
        <span class="n">coarse_operator</span> <span class="o">=</span> <span class="n">Lc</span><span class="p">,</span>
        <span class="n">interpolation</span> <span class="o">=</span> <span class="n">P</span><span class="p">,</span>
        <span class="n">restriction</span> <span class="o">=</span> <span class="n">R</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">cgc</span> <span class="o">*</span> <span class="n">S</span>

<span class="nb">print</span><span class="p">((</span><span class="n">E</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="section" id="multigrid-method">
<h2>Multigrid Method<a class="headerlink" href="#multigrid-method" title="Permalink to this headline">¶</a></h2>
<p>To define the error propagation operator of a multigrid method, we use the
<cite>coarse_error</cite> argument of the
<code class="xref py py-func docutils literal notranslate"><span class="pre">lfa_lab.twogrid.coarse_grid_correction()</span></code> function. This argument
gives the error propagator of the coarse grid solver. Hence, we can write a
recursive function that computes the error propagator of the multigrid method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lfa_lab</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">multigrid</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">fine_grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a tuple consisting of the error propagation operator and the</span>
<span class="sd">    linear system operator of a multigrid method.&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">poisson_2d</span><span class="p">(</span><span class="n">fine_grid</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Solve exactly on the coarsest grid, hence return the zero operator.</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">fine_grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coarse_grid</span> <span class="o">=</span> <span class="n">fine_grid</span><span class="o">.</span><span class="n">coarse</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">Ec</span><span class="p">,</span> <span class="n">Lc</span> <span class="o">=</span> <span class="n">multigrid</span><span class="p">(</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coarse_grid</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">jacobi</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">fw_restriction</span><span class="p">(</span><span class="n">fine_grid</span><span class="p">,</span> <span class="n">coarse_grid</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">gallery</span><span class="o">.</span><span class="n">ml_interpolation</span><span class="p">(</span><span class="n">fine_grid</span><span class="p">,</span> <span class="n">coarse_grid</span><span class="p">)</span>

        <span class="n">cgc</span> <span class="o">=</span> <span class="n">coarse_grid_correction</span><span class="p">(</span>
                <span class="n">operator</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span>
                <span class="n">coarse_operator</span> <span class="o">=</span> <span class="n">Lc</span><span class="p">,</span>
                <span class="n">interpolation</span> <span class="o">=</span> <span class="n">P</span><span class="p">,</span>
                <span class="n">restriction</span> <span class="o">=</span> <span class="n">R</span><span class="p">,</span>
                <span class="n">coarse_error</span> <span class="o">=</span> <span class="n">Ec</span><span class="p">)</span>

        <span class="c1"># Apply one pre- and one post-smoothing step.</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">cgc</span> <span class="o">*</span> <span class="n">S</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

<span class="c1"># Compute error propagation operator of a three-grid method</span>
<span class="n">fine_grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">32</span><span class="p">])</span>
<span class="n">E</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">multigrid</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">fine_grid</span><span class="p">)</span>

<span class="nb">print</span><span class="p">((</span><span class="n">E</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span><span class="o">.</span><span class="n">spectral_radius</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/lfa_lab_logo.png" alt="Logo"/>
            </a></p>
<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-jacobi-method">The Jacobi Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plotting-symbols">Plotting Symbols</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smoothing-analysis">Smoothing Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#two-grids">Two Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-stencil-operators">Defining Stencil Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multigrid-method">Multigrid Method</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="citation.html">Publications &amp; Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Hannah Rittich.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>